class g{static instance;db=null;initPromise=null;jsonicModule=null;constructor(){}static getInstance(){return g.instance||(g.instance=new g),g.instance}async initialize(){if(!this.db)return this.initPromise||(this.initPromise=this.performInitialization()),this.initPromise}async performInitialization(){const e=performance.now();console.log("[JSONIC] Starting initialization...");try{const t="/agentx-benchmark-ui/",a=typeof window>"u"&&typeof self<"u";let s;a?s="hybrid":s=new URLSearchParams(window.location.search).get("wrapper")||void 0||"hybrid";let n;a?n=`${t}jsonic-worker-wrapper.js`:s==="lightweight"||s==="v1"?(console.log("[JSONIC] Using LIGHTWEIGHT v1 wrapper for faster init"),n=`${t}jsonic-wrapper.esm.js`):s==="v3"?(console.log("[JSONIC] Using FULL v3.1 wrapper with all features"),n=`${t}jsonic-wrapper-v3.esm.js`):(console.log("[JSONIC] Using HYBRID wrapper (v4) - fast init + progressive features"),n=`${t}jsonic-hybrid/index.js`),console.log("[JSONIC] Loading wrapper from:",n);const r=performance.now(),d=await import(n);if(this.jsonicModule=d.default,console.log(`[JSONIC] Module loaded in ${(performance.now()-r).toFixed(2)}ms`),!this.jsonicModule)throw new Error("JSONIC module not found");let l;a?l="/agentx-benchmark-ui/jsonic_wasm_bg.wasm":l=typeof window<"u"&&window.location.pathname.startsWith("/agentx-benchmark-ui/")?"/agentx-benchmark-ui/jsonic_wasm_bg.wasm":`${t}jsonic_wasm_bg.wasm`;const i=performance.now(),o={wasmUrl:l,debug:!0,enablePersistence:!1,persistenceKey:"agentx_benchmark_db"};(s==="v3"||s==="hybrid")&&(o.cacheSize=100,o.enableQueryCache=!0,o.enableBatchOptimization=!0,o.memoryLimit=100*1024*1024,o.indexHints={testId:"hash",timestamp:"btree",status:"hash",agentId:"hash",type:"hash"},s==="hybrid"&&(o.preloadFeatures=["cache","batch"])),this.jsonicModule.configure(o),console.log(`[JSONIC] Configuration completed in ${(performance.now()-i).toFixed(2)}ms`),console.log("JSONIC version:",this.jsonicModule.version),console.log("WASM URL:",l),console.log("Features: Query caching, Batch operations, Index optimization, OPFS persistence");const u=performance.now();this.db=await this.jsonicModule.createDatabase({enablePersistence:!1,persistenceKey:"agentx_benchmark_db",cacheSize:100,enableQueryCache:!0,enableBatchOptimization:!0,memoryLimit:100*1024*1024,indexHints:{testId:"hash",timestamp:"btree",status:"hash",agentId:"hash",type:"hash"},debug:!0}),console.log(`[JSONIC] Database created in ${(performance.now()-u).toFixed(2)}ms`),console.log("JSONIC v3.1 database initialized with performance optimizations");const h=performance.now(),p=await this.db.stats();console.log(`[JSONIC] Stats retrieved in ${(performance.now()-h).toFixed(2)}ms`),console.log("JSONIC stats:",p);const b=performance.now()-e;console.log(`[JSONIC] Total initialization time: ${b.toFixed(2)}ms`),b>1e3&&console.warn(`[JSONIC] ⚠️ Slow initialization detected: ${b.toFixed(2)}ms`)}catch(t){throw console.error("Failed to initialize JSONIC:",t),console.error(`[JSONIC] Failed after ${(performance.now()-e).toFixed(2)}ms`),t}}async getDatabase(){if(this.db||await this.initialize(),!this.db)throw new Error("JSONIC database not initialized");return this.db}async insert(e){return(await this.getDatabase()).insert(e)}async get(e){return(await this.getDatabase()).get(e)}async update(e,t){if(!await(await this.getDatabase()).update(e,t))throw new Error("Failed to update document")}async delete(e){if(!await(await this.getDatabase()).delete(e))throw new Error("Failed to delete document")}async listIds(){return(await this.getDatabase()).list()}async getStats(){return(await this.getDatabase()).stats()}async query(e){const t=await this.getDatabase(),a=await t.list(),s=[];for(const n of a){const r=await t.get(n);r&&r.content&&e(r.content)&&s.push({id:n,...r.content})}return s}async findDocuments(e,t){return(await this.getDatabase()).query(e,t)}async findOne(e){return(await this.getDatabase()).findOne(e)}find(e={}){const t=this.getDatabase(),a={sort:function(n){return this},limit:function(n){return this},skip:function(n){return this},project:function(n){return this},exec:async function(){return(await t).find(e).exec()},toArray:async function(){return(await t).find(e).toArray()},count:async function(){return(await t).find(e).count()}};let s={};return a.sort=n=>(s.sort=Object.entries(n).map(([r,d])=>[r,d]),a),a.limit=n=>(s.limit=n,a),a.skip=n=>(s.skip=n,a),a.project=n=>(s.projection=n,a),a.exec=async()=>(await t).query(e,s),a.toArray=async()=>(await t).query(e,s),a.count=async()=>(await t).find(e).count(),a}async insertMany(e){return(await this.getDatabase()).insertMany(e)}async updateMany(e,t){return(await this.getDatabase()).updateMany(e,t)}async deleteMany(e){return(await this.getDatabase()).deleteMany(e)}async aggregate(e){return(await this.getDatabase()).aggregate(e)}async getDebugInfo(){return(await this.getDatabase()).getDebugInfo()}async clearCache(){(await this.getDatabase()).clearCache()}async clearProfiler(){(await this.getDatabase()).clearProfiler()}async getBenchmarkStats(e){const t=[];return e&&t.push({$match:{testId:e}}),t.push({$group:{_id:"$testId",avgDuration:{$avg:"$duration"},minDuration:{$min:"$duration"},maxDuration:{$max:"$duration"},totalRuns:{$sum:1},successCount:{$sum:{$cond:[{$eq:["$status","success"]},1,0]}},failureCount:{$sum:{$cond:[{$eq:["$status","failure"]},1,0]}}}},{$sort:{totalRuns:-1}}),this.aggregate(t)}}const f=g.getInstance(),m=c=>{self.postMessage({type:"progress",payload:c})},w=async()=>{try{console.log("🔧 WORKER: Starting JSONIC migration..."),m({phase:"loading",current:0,total:100,message:"Loading data in background...",percentage:10});const c="/agentx-benchmark-ui/",e=new URL(`${c}data/database.json`,self.location.origin).href,t=await fetch(e);if(!t.ok)throw new Error(`Failed to fetch database.json: ${t.status}`);const a=await t.json(),s=(a.benchmark_runs?.length||0)+(a.model_performance?.length||0)+(a.test_results?.length||0)+(a.performance_trends?.length||0);console.log(`🔧 WORKER: Processing ${s} documents`),m({phase:"migrating",current:0,total:s,message:"Initializing JSONIC in worker...",percentage:15}),await f.initialize();let n=0;const r=50,d=async i=>{for(let o=0;o<i.length;o+=r){const u=i.slice(o,Math.min(o+r,i.length));await Promise.all(u.map(p=>f.insert(p))),n+=u.length;const h=20+n/s*70;m({phase:"migrating",current:n,total:s,message:`Processing documents... (${n}/${s})`,percentage:h})}},l=(i,o,u)=>({_type:i,_runId:u,_timestamp:new Date().toISOString(),...o});if(a.benchmark_runs){const i=a.benchmark_runs.map(o=>l("benchmark_run",o));await d(i),console.log(`🔧 WORKER: Migrated ${i.length} benchmark runs`)}if(a.model_performance){const i=a.model_performance.map(o=>l("model_performance",o,o.run_id));await d(i),console.log(`🔧 WORKER: Migrated ${i.length} model performance records`)}if(a.test_results){const i=a.test_results.map(o=>l("test_result",o,o.run_id));await d(i),console.log(`🔧 WORKER: Migrated ${i.length} test results`)}if(a.performance_trends){const i=a.performance_trends.map(o=>l("performance_trend",o));await d(i),console.log(`🔧 WORKER: Migrated ${i.length} performance trends`)}m({phase:"complete",current:s,total:s,message:`✅ Migration complete! ${s} documents processed.`,percentage:100}),console.log(`🎉 WORKER: Migration successful - ${s} documents`),self.postMessage({type:"migrationComplete",payload:!0})}catch(c){console.error("❌ WORKER: Migration failed:",c),m({phase:"error",current:0,total:100,message:c instanceof Error?c.message:"Unknown worker error",percentage:0}),self.postMessage({type:"migrationComplete",payload:!1})}};self.onmessage=c=>{c.data.type==="startMigration"&&w()};
//# sourceMappingURL=migration.worker-DmWTz9j5.js.map

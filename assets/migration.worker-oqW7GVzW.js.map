{"version":3,"file":"migration.worker-oqW7GVzW.js","sources":["../src/services/jsonicService.ts","../src/services/migration.worker.ts"],"sourcesContent":["interface JsonicDatabase {\n  insert(data: any): Promise<string>;\n  get(id: string): Promise<any>;\n  update(id: string, data: any): Promise<boolean>;\n  delete(id: string): Promise<boolean>;\n  list(): Promise<string[]>;\n  stats(): Promise<any>;\n  query(filter: any, options?: QueryOptions): Promise<any[]>;\n  find(filter?: any): QueryChainable;\n  findOne(filter?: any): Promise<any>;\n}\n\ninterface QueryOptions {\n  projection?: Record<string, boolean>;\n  sort?: Array<[string, number]>;\n  limit?: number;\n  skip?: number;\n}\n\ninterface QueryChainable {\n  sort(sortSpec: Record<string, number>): QueryChainable;\n  limit(n: number): QueryChainable;\n  skip(n: number): QueryChainable;\n  project(projection: Record<string, boolean>): QueryChainable;\n  exec(): Promise<any[]>;\n  toArray(): Promise<any[]>;\n}\n\ninterface JSONIC {\n  createDatabase(options?: { \n    enablePersistence?: boolean; \n    persistenceKey?: string;\n  }): Promise<JsonicDatabase>;\n  configure(options: { \n    wasmUrl?: string; \n    debug?: boolean;\n    enablePersistence?: boolean;\n    persistenceKey?: string;\n  }): void;\n  version: string;\n}\n\nclass JsonicService {\n  private static instance: JsonicService;\n  private db: JsonicDatabase | null = null;\n  private initPromise: Promise<void> | null = null;\n  private jsonicModule: JSONIC | null = null;\n  \n  private constructor() {}\n  \n  static getInstance(): JsonicService {\n    if (!JsonicService.instance) {\n      JsonicService.instance = new JsonicService();\n    }\n    return JsonicService.instance;\n  }\n  \n  async initialize(): Promise<void> {\n    if (this.db) return;\n    \n    if (!this.initPromise) {\n      this.initPromise = this.performInitialization();\n    }\n    \n    return this.initPromise;\n  }\n  \n  private async performInitialization(): Promise<void> {\n    try {\n      // Build the correct URL for the ES module wrapper\n      const baseUrl = import.meta.env.BASE_URL || '/';\n      \n      // Check if we're in a Web Worker (no window object)\n      const isWorker = typeof window === 'undefined' && typeof self !== 'undefined';\n      \n      // Use worker-safe wrapper in Web Workers\n      let jsonicUrl: string;\n      if (isWorker) {\n        // In worker, use worker-safe wrapper\n        jsonicUrl = `${baseUrl}jsonic-worker-wrapper.js`;\n      } else if (import.meta.env.DEV) {\n        // In development, use absolute URL\n        jsonicUrl = `${window.location.origin}/jsonic-wrapper.esm.js`;\n      } else {\n        // In production, use relative path\n        jsonicUrl = `${baseUrl}jsonic-wrapper.esm.js`;\n      }\n      \n      // Dynamically import the ES module\n      const module = await import(/* @vite-ignore */ jsonicUrl) as { default: JSONIC };\n      this.jsonicModule = module.default;\n      \n      if (!this.jsonicModule) {\n        throw new Error('JSONIC module not found');\n      }\n      \n      // Configure JSONIC with correct paths for both dev and production (GitHub Pages)\n      const wasmUrl = window.location.pathname.startsWith('/agentx-benchmark-ui/') \n        ? '/agentx-benchmark-ui/jsonic_wasm_bg.wasm'\n        : `${baseUrl}jsonic_wasm_bg.wasm`;\n        \n      this.jsonicModule.configure({\n        wasmUrl,\n        debug: import.meta.env.DEV,\n        enablePersistence: true,\n        persistenceKey: 'agentx_benchmark_db'\n      });\n      \n      console.log('JSONIC version:', this.jsonicModule.version);\n      console.log('WASM URL:', wasmUrl);\n      \n      this.db = await this.jsonicModule.createDatabase({\n        enablePersistence: true,\n        persistenceKey: 'agentx_benchmark_db'\n      });\n      console.log('JSONIC database initialized with MongoDB-like queries and OPFS persistence');\n      \n      const stats = await this.db.stats();\n      console.log('JSONIC stats:', stats);\n    } catch (error) {\n      console.error('Failed to initialize JSONIC:', error);\n      throw error;\n    }\n  }\n  \n  async getDatabase(): Promise<JsonicDatabase> {\n    if (!this.db) {\n      await this.initialize();\n    }\n    \n    if (!this.db) {\n      throw new Error('JSONIC database not initialized');\n    }\n    \n    return this.db;\n  }\n  \n  async insert(data: any): Promise<string> {\n    const db = await this.getDatabase();\n    return db.insert(data);\n  }\n  \n  async get(id: string): Promise<any> {\n    const db = await this.getDatabase();\n    return db.get(id);\n  }\n  \n  async update(id: string, data: any): Promise<void> {\n    const db = await this.getDatabase();\n    const result = await db.update(id, data);\n    if (!result) {\n      throw new Error('Failed to update document');\n    }\n  }\n  \n  async delete(id: string): Promise<void> {\n    const db = await this.getDatabase();\n    const result = await db.delete(id);\n    if (!result) {\n      throw new Error('Failed to delete document');\n    }\n  }\n  \n  async listIds(): Promise<string[]> {\n    const db = await this.getDatabase();\n    return db.list();\n  }\n  \n  async getStats(): Promise<any> {\n    const db = await this.getDatabase();\n    return db.stats();\n  }\n  \n  async query(filter: (item: any) => boolean): Promise<any[]> {\n    const db = await this.getDatabase();\n    const ids = await db.list();\n    const results: any[] = [];\n    \n    for (const id of ids) {\n      const doc = await db.get(id);\n      if (doc && doc.content) {\n        // The actual data is in doc.content\n        if (filter(doc.content)) {\n          results.push({ id, ...doc.content });\n        }\n      }\n    }\n    \n    return results;\n  }\n\n  // New MongoDB-like query methods\n  async findDocuments(filter: any, options?: QueryOptions): Promise<any[]> {\n    const db = await this.getDatabase();\n    return db.query(filter, options);\n  }\n\n  async findOne(filter: any): Promise<any> {\n    const db = await this.getDatabase();\n    return db.findOne(filter);\n  }\n\n  find(filter: any = {}): QueryChainable {\n    // Return a promise that resolves to a chainable query\n    const dbPromise = this.getDatabase();\n    \n    const chainable = {\n      sort: function(_sortSpec: Record<string, number>) {\n        return this;\n      },\n      limit: function(_n: number) {\n        return this;\n      },\n      skip: function(_n: number) {\n        return this;\n      },\n      project: function(_projection: Record<string, boolean>) {\n        return this;\n      },\n      exec: async function() {\n        const db = await dbPromise;\n        return db.find(filter).exec();\n      },\n      toArray: async function() {\n        const db = await dbPromise;\n        return db.find(filter).toArray();\n      }\n    } as QueryChainable;\n\n    // Make chainable methods actually chain properly\n    let queryOptions: QueryOptions = {};\n    \n    chainable.sort = (sortSpec: Record<string, number>) => {\n      queryOptions.sort = Object.entries(sortSpec).map(([k, v]) => [k, v]);\n      return chainable;\n    };\n    \n    chainable.limit = (n: number) => {\n      queryOptions.limit = n;\n      return chainable;\n    };\n    \n    chainable.skip = (n: number) => {\n      queryOptions.skip = n;\n      return chainable;\n    };\n    \n    chainable.project = (projection: Record<string, boolean>) => {\n      queryOptions.projection = projection;\n      return chainable;\n    };\n    \n    chainable.exec = async () => {\n      const db = await dbPromise;\n      return db.query(filter, queryOptions);\n    };\n    \n    chainable.toArray = async () => {\n      const db = await dbPromise;\n      return db.query(filter, queryOptions);\n    };\n    \n    return chainable;\n  }\n}\n\nexport const jsonicService = JsonicService.getInstance();","// Web Worker for JSONIC database operations\n// This runs in a separate thread to avoid blocking the main UI thread\n\nimport { jsonicService } from './jsonicService';\n\n// Post messages back to the main thread\nconst postProgress = (progress: any) => {\n  self.postMessage({ type: 'progress', payload: progress });\n};\n\nconst performMigration = async () => {\n  try {\n    console.log('ðŸ”§ WORKER: Starting JSONIC migration...');\n    postProgress({\n      phase: 'loading',\n      current: 0,\n      total: 100,\n      message: 'Loading data in background...',\n      percentage: 10,\n    });\n\n    // In a worker, we need to construct the full URL to the data file\n    const basePath = '/agentx-benchmark-ui/'; // GitHub Pages base path\n    const dataUrl = new URL(`${basePath}data/database.json`, self.location.origin).href;\n\n    const response = await fetch(dataUrl);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch database.json: ${response.status}`);\n    }\n    const jsonData = await response.json();\n\n    const totalDocs =\n      (jsonData.benchmark_runs?.length || 0) +\n      (jsonData.model_performance?.length || 0) +\n      (jsonData.test_results?.length || 0) +\n      (jsonData.performance_trends?.length || 0);\n\n    console.log(`ðŸ”§ WORKER: Processing ${totalDocs} documents`);\n\n    postProgress({\n      phase: 'migrating',\n      current: 0,\n      total: totalDocs,\n      message: 'Initializing JSONIC in worker...',\n      percentage: 15,\n    });\n\n    // Initialize JSONIC in the worker thread\n    await jsonicService.initialize();\n\n    let migratedCount = 0;\n    const BATCH_SIZE = 50; // Larger batches are fine in a worker\n\n    const insertBatch = async (documents: any[]) => {\n      for (let i = 0; i < documents.length; i += BATCH_SIZE) {\n        const batch = documents.slice(i, Math.min(i + BATCH_SIZE, documents.length));\n\n        // Insert batch in parallel within worker\n        await Promise.all(\n          batch.map(doc => jsonicService.insert(doc))\n        );\n\n        migratedCount += batch.length;\n        const percentage = 20 + (migratedCount / totalDocs) * 70;\n        \n        postProgress({\n          phase: 'migrating',\n          current: migratedCount,\n          total: totalDocs,\n          message: `Processing documents... (${migratedCount}/${totalDocs})`,\n          percentage,\n        });\n      }\n    };\n\n    // Helper to create document with type tagging\n    const createDocument = (type: string, data: any, runId?: string) => ({\n      _type: type,\n      _runId: runId,\n      _timestamp: new Date().toISOString(),\n      ...data\n    });\n\n    // Process data in order of importance\n    if (jsonData.benchmark_runs) {\n      const docs = jsonData.benchmark_runs.map((run: any) => \n        createDocument('benchmark_run', run)\n      );\n      await insertBatch(docs);\n      console.log(`ðŸ”§ WORKER: Migrated ${docs.length} benchmark runs`);\n    }\n\n    if (jsonData.model_performance) {\n      const docs = jsonData.model_performance.map((perf: any) => \n        createDocument('model_performance', perf, perf.run_id)\n      );\n      await insertBatch(docs);\n      console.log(`ðŸ”§ WORKER: Migrated ${docs.length} model performance records`);\n    }\n\n    if (jsonData.test_results) {\n      const docs = jsonData.test_results.map((test: any) => \n        createDocument('test_result', test, test.run_id)\n      );\n      await insertBatch(docs);\n      console.log(`ðŸ”§ WORKER: Migrated ${docs.length} test results`);\n    }\n\n    if (jsonData.performance_trends) {\n      const docs = jsonData.performance_trends.map((trend: any) => \n        createDocument('performance_trend', trend)\n      );\n      await insertBatch(docs);\n      console.log(`ðŸ”§ WORKER: Migrated ${docs.length} performance trends`);\n    }\n\n    postProgress({\n      phase: 'complete',\n      current: totalDocs,\n      total: totalDocs,\n      message: `âœ… Migration complete! ${totalDocs} documents processed.`,\n      percentage: 100,\n    });\n\n    console.log(`ðŸŽ‰ WORKER: Migration successful - ${totalDocs} documents`);\n    self.postMessage({ type: 'migrationComplete', payload: true });\n\n  } catch (error) {\n    console.error('âŒ WORKER: Migration failed:', error);\n    postProgress({\n      phase: 'error',\n      current: 0,\n      total: 100,\n      message: error instanceof Error ? error.message : 'Unknown worker error',\n      percentage: 0,\n    });\n    self.postMessage({ type: 'migrationComplete', payload: false });\n  }\n};\n\n// Listen for messages from the main thread\nself.onmessage = (event) => {\n  if (event.data.type === 'startMigration') {\n    performMigration();\n  }\n};\n\nexport {};"],"names":["JsonicService","baseUrl","isWorker","jsonicUrl","module","wasmUrl","stats","error","data","id","filter","db","ids","results","doc","options","dbPromise","chainable","_sortSpec","_n","_projection","queryOptions","sortSpec","k","v","projection","jsonicService","postProgress","progress","performMigration","basePath","dataUrl","response","jsonData","totalDocs","migratedCount","BATCH_SIZE","insertBatch","documents","i","batch","percentage","createDocument","type","runId","docs","run","perf","test","trend","event"],"mappings":"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"}
class g{static instance;db=null;collection=null;initPromise=null;jsonicModule=null;constructor(){}static getInstance(){return g.instance||(g.instance=new g),g.instance}async initialize(){if(!this.db)return this.initPromise||(this.initPromise=this.performInitialization()),this.initPromise}async performInitialization(){const t=performance.now();console.log("[JSONIC v3.3] Starting initialization..."),console.log("[JSONIC] Environment:",{isDev:!1,baseUrl:"/agentx-benchmark-ui/",mode:"production",location:typeof window<"u"?window.location.href:"worker"});try{try{console.log("[JSONIC] Attempting to load jsonic-db from npm package...");const{JSONIC:n}=await import("jsonic-db"),i=performance.now();this.db=await n.create({name:"agentx_benchmark",persistence:!1,crossTabSync:!1}),console.log(`[JSONIC] Database created in ${(performance.now()-i).toFixed(2)}ms`),this.collection=this.db.collection("benchmarks"),console.log("[JSONIC v3.3] Initialized successfully with new API")}catch(n){console.warn("[JSONIC] npm package not available, falling back to legacy wrapper:",n);const i="/agentx-benchmark-ui/",r=typeof window>"u"&&typeof self<"u";let c;r?c=`${i}jsonic-worker-wrapper.js`:c=`${i}jsonic-hybrid/index.js`,console.log("[JSONIC] Loading legacy wrapper from:",c);const l=await import(c);if(this.jsonicModule=l.default,!this.jsonicModule)throw new Error("JSONIC module not found");const d=performance.now();this.db=await this.jsonicModule.create({name:"agentx_benchmark",persistence:!1}),console.log(`[JSONIC] Legacy database created in ${(performance.now()-d).toFixed(2)}ms`),this.collection=this.db.collection("benchmarks")}const e=performance.now()-t;console.log(`[JSONIC] Total initialization time: ${e.toFixed(2)}ms`),e>1e3&&console.warn(`[JSONIC] ⚠️ Slow initialization: ${e.toFixed(2)}ms`)}catch(e){throw console.error("[JSONIC] Failed to initialize:",e),console.error(`[JSONIC] Failed after ${(performance.now()-t).toFixed(2)}ms`),e}}async getDatabase(){if(this.db||await this.initialize(),!this.db)throw new Error("JSONIC database not initialized");return this.db}async getCollection(){if(this.collection||await this.initialize(),!this.collection)throw new Error("JSONIC collection not initialized");return this.collection}async insert(t){return(await(await this.getCollection()).insertOne(t))._id}async get(t){return(await this.getCollection()).findOne({_id:t})}async update(t,e){await(await this.getCollection()).updateOne({_id:t},{$set:e})}async delete(t){await(await this.getCollection()).deleteOne({_id:t})}async listIds(){return(await(await this.getCollection()).find({},{projection:{_id:1}})).map(n=>n._id)}async getStats(){return{documentCount:await(await this.getCollection()).count(),collectionName:"benchmarks"}}async query(t){return(await(await this.getCollection()).find({})).filter(t)}async findDocuments(t,e){return(await this.getCollection()).find(t,e)}async findOne(t){return(await this.getCollection()).findOne(t)}async find(t={},e){return(await this.getCollection()).find(t,e)}async insertMany(t){return(await(await this.getCollection()).insertMany(t)).insertedIds}async updateMany(t,e){return(await this.getCollection()).updateMany(t,e)}async deleteMany(t){return(await this.getCollection()).deleteMany(t)}async aggregate(t){return(await this.getCollection()).aggregate(t)}async count(t={}){return(await this.getCollection()).count(t)}async getBenchmarkStats(t){const e=[];return t&&e.push({$match:{testId:t}}),e.push({$group:{_id:"$testId",avgDuration:{$avg:"$duration"},minDuration:{$min:"$duration"},maxDuration:{$max:"$duration"},totalRuns:{$sum:1},successCount:{$sum:{$cond:[{$eq:["$status","success"]},1,0]}},failureCount:{$sum:{$cond:[{$eq:["$status","failure"]},1,0]}}}},{$sort:{totalRuns:-1}}),this.aggregate(e)}}const h=g.getInstance(),m=s=>{self.postMessage({type:"progress",payload:s})},w=async()=>{try{console.log("🔧 WORKER: Starting JSONIC migration..."),m({phase:"loading",current:0,total:100,message:"Loading data in background...",percentage:10});const s="/agentx-benchmark-ui/",t=new URL(`${s}data/database.json`,self.location.origin).href,e=await fetch(t);if(!e.ok)throw new Error(`Failed to fetch database.json: ${e.status}`);const n=await e.json(),i=(n.benchmark_runs?.length||0)+(n.model_performance?.length||0)+(n.test_results?.length||0)+(n.performance_trends?.length||0);console.log(`🔧 WORKER: Processing ${i} documents`),m({phase:"migrating",current:0,total:i,message:"Initializing JSONIC in worker...",percentage:15}),await h.initialize();let r=0;const c=50,l=async o=>{for(let a=0;a<o.length;a+=c){const u=o.slice(a,Math.min(a+c,o.length));await Promise.all(u.map(f=>h.insert(f))),r+=u.length;const p=20+r/i*70;m({phase:"migrating",current:r,total:i,message:`Processing documents... (${r}/${i})`,percentage:p})}},d=(o,a,u)=>({_type:o,_runId:u,_timestamp:new Date().toISOString(),...a});if(n.benchmark_runs){const o=n.benchmark_runs.map(a=>d("benchmark_run",a));await l(o),console.log(`🔧 WORKER: Migrated ${o.length} benchmark runs`)}if(n.model_performance){const o=n.model_performance.map(a=>d("model_performance",a,a.run_id));await l(o),console.log(`🔧 WORKER: Migrated ${o.length} model performance records`)}if(n.test_results){const o=n.test_results.map(a=>d("test_result",a,a.run_id));await l(o),console.log(`🔧 WORKER: Migrated ${o.length} test results`)}if(n.performance_trends){const o=n.performance_trends.map(a=>d("performance_trend",a));await l(o),console.log(`🔧 WORKER: Migrated ${o.length} performance trends`)}m({phase:"complete",current:i,total:i,message:`✅ Migration complete! ${i} documents processed.`,percentage:100}),console.log(`🎉 WORKER: Migration successful - ${i} documents`),self.postMessage({type:"migrationComplete",payload:!0})}catch(s){console.error("❌ WORKER: Migration failed:",s),m({phase:"error",current:0,total:100,message:s instanceof Error?s.message:"Unknown worker error",percentage:0}),self.postMessage({type:"migrationComplete",payload:!1})}};self.onmessage=s=>{s.data.type==="startMigration"&&w()};
//# sourceMappingURL=migration.worker-_6yYlvRW.js.map

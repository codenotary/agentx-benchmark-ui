{"version":3,"file":"migration.worker-_6yYlvRW.js","sources":["../src/services/jsonicService.ts","../src/services/migration.worker.ts"],"sourcesContent":["// JSONIC v3.3 Collection-based API\ninterface JsonicCollection {\n  insertOne(doc: any): Promise<{ _id: string }>;\n  insertMany(docs: any[]): Promise<{ insertedIds: string[] }>;\n  findOne(filter: any): Promise<any>;\n  find(filter: any, options?: FindOptions): Promise<any[]>;\n  updateOne(filter: any, update: any): Promise<UpdateResult>;\n  updateMany(filter: any, update: any): Promise<UpdateResult>;\n  deleteOne(filter: any): Promise<DeleteResult>;\n  deleteMany(filter: any): Promise<DeleteResult>;\n  aggregate(pipeline: any[]): Promise<any[]>;\n  count(filter?: any): Promise<number>;\n}\n\ninterface JsonicDatabase {\n  collection(name: string): JsonicCollection;\n  export(): Promise<any>;\n  exportToFile(filename: string): Promise<void>;\n}\n\ninterface FindOptions {\n  limit?: number;\n  skip?: number;\n  sort?: Record<string, 1 | -1>;\n  projection?: Record<string, 0 | 1>;\n}\n\ninterface UpdateResult {\n  matchedCount: number;\n  modifiedCount: number;\n}\n\ninterface DeleteResult {\n  deletedCount: number;\n}\n\n// JSONIC v3.3 API\ninterface JSONIC {\n  create(options?: {\n    name?: string;\n    version?: number;\n    persistence?: boolean;\n    persistenceConfig?: {\n      wasmPath?: string;\n      workerPath?: string;\n      snapshotInterval?: number;\n    };\n    crossTabSync?: boolean;\n    syncChannel?: string;\n  }): Promise<JsonicDatabase>;\n}\n\nclass JsonicService {\n  private static instance: JsonicService;\n  private db: JsonicDatabase | null = null;\n  private collection: JsonicCollection | null = null;\n  private initPromise: Promise<void> | null = null;\n  private jsonicModule: JSONIC | null = null;\n\n  private constructor() {}\n\n  static getInstance(): JsonicService {\n    if (!JsonicService.instance) {\n      JsonicService.instance = new JsonicService();\n    }\n    return JsonicService.instance;\n  }\n  \n  async initialize(): Promise<void> {\n    if (this.db) return;\n    \n    if (!this.initPromise) {\n      this.initPromise = this.performInitialization();\n    }\n    \n    return this.initPromise;\n  }\n  \n  private async performInitialization(): Promise<void> {\n    const initStartTime = performance.now();\n    console.log('[JSONIC v3.3] Starting initialization...');\n    console.log('[JSONIC] Environment:', {\n      isDev: import.meta.env.DEV,\n      baseUrl: import.meta.env.BASE_URL,\n      mode: import.meta.env.MODE,\n      location: typeof window !== 'undefined' ? window.location.href : 'worker',\n    });\n\n    try {\n      // Try to load JSONIC v3.3 from the npm package\n      // Falls back to legacy wrappers if not available\n      try {\n        console.log('[JSONIC] Attempting to load jsonic-db from npm package...');\n        const { JSONIC: JSONICModule } = await import('jsonic-db');\n\n        // Create database using v3.3 API\n        const dbCreateStartTime = performance.now();\n        this.db = await JSONICModule.create({\n          name: 'agentx_benchmark',\n          persistence: false, // Disabled for faster development\n          crossTabSync: false\n        });\n        console.log(`[JSONIC] Database created in ${(performance.now() - dbCreateStartTime).toFixed(2)}ms`);\n\n        // Get default collection for benchmarks\n        this.collection = this.db.collection('benchmarks');\n\n        console.log('[JSONIC v3.3] Initialized successfully with new API');\n\n      } catch (npmError) {\n        console.warn('[JSONIC] npm package not available, falling back to legacy wrapper:', npmError);\n\n        // Fallback to legacy wrapper implementation\n        const baseUrl = import.meta.env.BASE_URL || '/';\n        const isWorker = typeof window === 'undefined' && typeof self !== 'undefined';\n\n        let jsonicUrl: string;\n        if (isWorker) {\n          jsonicUrl = `${baseUrl}jsonic-worker-wrapper.js`;\n        } else {\n          jsonicUrl = import.meta.env.DEV\n            ? `${self.location ? self.location.origin : 'http://localhost:5173'}/jsonic-hybrid/index.js`\n            : `${baseUrl}jsonic-hybrid/index.js`;\n        }\n\n        console.log('[JSONIC] Loading legacy wrapper from:', jsonicUrl);\n\n        const module = await import(/* @vite-ignore */ jsonicUrl) as { default: JSONIC };\n        this.jsonicModule = module.default;\n\n        if (!this.jsonicModule) {\n          throw new Error('JSONIC module not found');\n        }\n\n        const dbCreateStartTime = performance.now();\n        this.db = await this.jsonicModule.create({\n          name: 'agentx_benchmark',\n          persistence: false\n        });\n        console.log(`[JSONIC] Legacy database created in ${(performance.now() - dbCreateStartTime).toFixed(2)}ms`);\n\n        this.collection = this.db.collection('benchmarks');\n      }\n\n      const totalInitTime = performance.now() - initStartTime;\n      console.log(`[JSONIC] Total initialization time: ${totalInitTime.toFixed(2)}ms`);\n\n      if (totalInitTime > 1000) {\n        console.warn(`[JSONIC] ‚ö†Ô∏è Slow initialization: ${totalInitTime.toFixed(2)}ms`);\n      }\n\n    } catch (error) {\n      console.error('[JSONIC] Failed to initialize:', error);\n      console.error(`[JSONIC] Failed after ${(performance.now() - initStartTime).toFixed(2)}ms`);\n      throw error;\n    }\n  }\n  \n  async getDatabase(): Promise<JsonicDatabase> {\n    if (!this.db) {\n      await this.initialize();\n    }\n\n    if (!this.db) {\n      throw new Error('JSONIC database not initialized');\n    }\n\n    return this.db;\n  }\n\n  async getCollection(): Promise<JsonicCollection> {\n    if (!this.collection) {\n      await this.initialize();\n    }\n\n    if (!this.collection) {\n      throw new Error('JSONIC collection not initialized');\n    }\n\n    return this.collection;\n  }\n\n  // Legacy compatibility methods - converted to collection API\n  async insert(data: any): Promise<string> {\n    const coll = await this.getCollection();\n    const result = await coll.insertOne(data);\n    return result._id;\n  }\n\n  async get(id: string): Promise<any> {\n    const coll = await this.getCollection();\n    return coll.findOne({ _id: id });\n  }\n\n  async update(id: string, data: any): Promise<void> {\n    const coll = await this.getCollection();\n    await coll.updateOne({ _id: id }, { $set: data });\n  }\n\n  async delete(id: string): Promise<void> {\n    const coll = await this.getCollection();\n    await coll.deleteOne({ _id: id });\n  }\n\n  async listIds(): Promise<string[]> {\n    const coll = await this.getCollection();\n    const docs = await coll.find({}, { projection: { _id: 1 } });\n    return docs.map(doc => doc._id);\n  }\n\n  async getStats(): Promise<any> {\n    const coll = await this.getCollection();\n    const count = await coll.count();\n    return {\n      documentCount: count,\n      collectionName: 'benchmarks'\n    };\n  }\n\n  async query(filter: (item: any) => boolean): Promise<any[]> {\n    const coll = await this.getCollection();\n    const docs = await coll.find({});\n    return docs.filter(filter);\n  }\n\n  // Collection-based query methods (v3.3 API)\n  async findDocuments(filter: any, options?: FindOptions): Promise<any[]> {\n    const coll = await this.getCollection();\n    return coll.find(filter, options);\n  }\n\n  async findOne(filter: any): Promise<any> {\n    const coll = await this.getCollection();\n    return coll.findOne(filter);\n  }\n\n  async find(filter: any = {}, options?: FindOptions): Promise<any[]> {\n    const coll = await this.getCollection();\n    return coll.find(filter, options);\n  }\n\n  // Batch operations (v3.3 API)\n  async insertMany(documents: any[]): Promise<string[]> {\n    const coll = await this.getCollection();\n    const result = await coll.insertMany(documents);\n    return result.insertedIds;\n  }\n\n  async updateMany(filter: any, update: any): Promise<UpdateResult> {\n    const coll = await this.getCollection();\n    return coll.updateMany(filter, update);\n  }\n\n  async deleteMany(filter: any): Promise<DeleteResult> {\n    const coll = await this.getCollection();\n    return coll.deleteMany(filter);\n  }\n\n  // Aggregation pipeline (v3.3 API)\n  async aggregate(pipeline: any[]): Promise<any[]> {\n    const coll = await this.getCollection();\n    return coll.aggregate(pipeline);\n  }\n\n  // Count documents\n  async count(filter: any = {}): Promise<number> {\n    const coll = await this.getCollection();\n    return coll.count(filter);\n  }\n\n  // Helper method for benchmark statistics using aggregation\n  async getBenchmarkStats(testId?: string): Promise<any> {\n    const pipeline: any[] = [];\n    \n    if (testId) {\n      pipeline.push({ $match: { testId } });\n    }\n    \n    pipeline.push(\n      {\n        $group: {\n          _id: '$testId',\n          avgDuration: { $avg: '$duration' },\n          minDuration: { $min: '$duration' },\n          maxDuration: { $max: '$duration' },\n          totalRuns: { $sum: 1 },\n          successCount: { $sum: { $cond: [{ $eq: ['$status', 'success'] }, 1, 0] } },\n          failureCount: { $sum: { $cond: [{ $eq: ['$status', 'failure'] }, 1, 0] } }\n        }\n      },\n      {\n        $sort: { totalRuns: -1 }\n      }\n    );\n    \n    return this.aggregate(pipeline);\n  }\n}\n\nexport const jsonicService = JsonicService.getInstance();","// Web Worker for JSONIC database operations\n// This runs in a separate thread to avoid blocking the main UI thread\n\nimport { jsonicService } from './jsonicService';\n\n// Post messages back to the main thread\nconst postProgress = (progress: any) => {\n  self.postMessage({ type: 'progress', payload: progress });\n};\n\nconst performMigration = async () => {\n  try {\n    console.log('üîß WORKER: Starting JSONIC migration...');\n    postProgress({\n      phase: 'loading',\n      current: 0,\n      total: 100,\n      message: 'Loading data in background...',\n      percentage: 10,\n    });\n\n    // In a worker, we need to construct the full URL to the data file\n    const basePath = '/agentx-benchmark-ui/'; // GitHub Pages base path\n    const dataUrl = new URL(`${basePath}data/database.json`, self.location.origin).href;\n\n    const response = await fetch(dataUrl);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch database.json: ${response.status}`);\n    }\n    const jsonData = await response.json();\n\n    const totalDocs =\n      (jsonData.benchmark_runs?.length || 0) +\n      (jsonData.model_performance?.length || 0) +\n      (jsonData.test_results?.length || 0) +\n      (jsonData.performance_trends?.length || 0);\n\n    console.log(`üîß WORKER: Processing ${totalDocs} documents`);\n\n    postProgress({\n      phase: 'migrating',\n      current: 0,\n      total: totalDocs,\n      message: 'Initializing JSONIC in worker...',\n      percentage: 15,\n    });\n\n    // Initialize JSONIC in the worker thread\n    await jsonicService.initialize();\n\n    let migratedCount = 0;\n    const BATCH_SIZE = 50; // Larger batches are fine in a worker\n\n    const insertBatch = async (documents: any[]) => {\n      for (let i = 0; i < documents.length; i += BATCH_SIZE) {\n        const batch = documents.slice(i, Math.min(i + BATCH_SIZE, documents.length));\n\n        // Insert batch in parallel within worker\n        await Promise.all(\n          batch.map(doc => jsonicService.insert(doc))\n        );\n\n        migratedCount += batch.length;\n        const percentage = 20 + (migratedCount / totalDocs) * 70;\n        \n        postProgress({\n          phase: 'migrating',\n          current: migratedCount,\n          total: totalDocs,\n          message: `Processing documents... (${migratedCount}/${totalDocs})`,\n          percentage,\n        });\n      }\n    };\n\n    // Helper to create document with type tagging\n    const createDocument = (type: string, data: any, runId?: string) => ({\n      _type: type,\n      _runId: runId,\n      _timestamp: new Date().toISOString(),\n      ...data\n    });\n\n    // Process data in order of importance\n    if (jsonData.benchmark_runs) {\n      const docs = jsonData.benchmark_runs.map((run: any) => \n        createDocument('benchmark_run', run)\n      );\n      await insertBatch(docs);\n      console.log(`üîß WORKER: Migrated ${docs.length} benchmark runs`);\n    }\n\n    if (jsonData.model_performance) {\n      const docs = jsonData.model_performance.map((perf: any) => \n        createDocument('model_performance', perf, perf.run_id)\n      );\n      await insertBatch(docs);\n      console.log(`üîß WORKER: Migrated ${docs.length} model performance records`);\n    }\n\n    if (jsonData.test_results) {\n      const docs = jsonData.test_results.map((test: any) => \n        createDocument('test_result', test, test.run_id)\n      );\n      await insertBatch(docs);\n      console.log(`üîß WORKER: Migrated ${docs.length} test results`);\n    }\n\n    if (jsonData.performance_trends) {\n      const docs = jsonData.performance_trends.map((trend: any) => \n        createDocument('performance_trend', trend)\n      );\n      await insertBatch(docs);\n      console.log(`üîß WORKER: Migrated ${docs.length} performance trends`);\n    }\n\n    postProgress({\n      phase: 'complete',\n      current: totalDocs,\n      total: totalDocs,\n      message: `‚úÖ Migration complete! ${totalDocs} documents processed.`,\n      percentage: 100,\n    });\n\n    console.log(`üéâ WORKER: Migration successful - ${totalDocs} documents`);\n    self.postMessage({ type: 'migrationComplete', payload: true });\n\n  } catch (error) {\n    console.error('‚ùå WORKER: Migration failed:', error);\n    postProgress({\n      phase: 'error',\n      current: 0,\n      total: 100,\n      message: error instanceof Error ? error.message : 'Unknown worker error',\n      percentage: 0,\n    });\n    self.postMessage({ type: 'migrationComplete', payload: false });\n  }\n};\n\n// Listen for messages from the main thread\nself.onmessage = (event) => {\n  if (event.data.type === 'startMigration') {\n    performMigration();\n  }\n};\n\nexport {};"],"names":["JsonicService","initStartTime","JSONICModule","dbCreateStartTime","npmError","baseUrl","isWorker","jsonicUrl","module","totalInitTime","error","data","id","doc","filter","options","documents","update","pipeline","testId","jsonicService","postProgress","progress","performMigration","basePath","dataUrl","response","jsonData","totalDocs","migratedCount","BATCH_SIZE","insertBatch","i","batch","percentage","createDocument","type","runId","docs","run","perf","test","trend","event"],"mappings":"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"}
{"version":3,"file":"migration.worker-D6DBfY5L.js","sources":["../src/services/jsonicService.ts","../src/services/migration.worker.ts"],"sourcesContent":["interface JsonicDatabase {\n  insert(data: any): Promise<string>;\n  insertMany(documents: any[], options?: any): Promise<string[]>;\n  get(id: string): Promise<any>;\n  update(id: string, data: any): Promise<boolean>;\n  updateMany(filter: any, update: any, options?: any): Promise<UpdateResult>;\n  delete(id: string): Promise<boolean>;\n  deleteMany(filter: any, options?: any): Promise<DeleteResult>;\n  list(): Promise<string[]>;\n  stats(): Promise<any>;\n  query(filter: any, options?: QueryOptions): Promise<any[]>;\n  find(filter?: any): QueryChainable;\n  findOne(filter?: any): Promise<any>;\n  aggregate(pipeline: any[]): Promise<any[]>;\n  getDebugInfo(): DebugInfo;\n  clearCache(): void;\n  clearProfiler(): void;\n}\n\ninterface QueryOptions {\n  projection?: Record<string, boolean>;\n  sort?: Array<[string, number]>;\n  limit?: number;\n  skip?: number;\n}\n\ninterface UpdateResult {\n  matchedCount: number;\n  modifiedCount: number;\n}\n\ninterface DeleteResult {\n  deletedCount: number;\n}\n\ninterface DebugInfo {\n  cache: {\n    size: number;\n    maxSize: number;\n    hits: number;\n    misses: number;\n    hitRate: string;\n  };\n  profiler: any;\n  slowQueries: any[];\n  indexes: Array<{\n    field: string;\n    type: string;\n    entries: number;\n  }>;\n  memory: {\n    used: number;\n    limit: number;\n    percentage: string;\n  };\n}\n\ninterface QueryChainable {\n  sort(sortSpec: Record<string, number>): QueryChainable;\n  limit(n: number): QueryChainable;\n  skip(n: number): QueryChainable;\n  project(projection: Record<string, boolean>): QueryChainable;\n  exec(): Promise<any[]>;\n  toArray(): Promise<any[]>;\n  count(): Promise<number>;\n}\n\ninterface JSONIC {\n  createDatabase(options?: { \n    enablePersistence?: boolean; \n    persistenceKey?: string;\n    cacheSize?: number;\n    enableQueryCache?: boolean;\n    enableBatchOptimization?: boolean;\n    memoryLimit?: number;\n    indexHints?: Record<string, string>;\n    debug?: boolean;\n  }): Promise<JsonicDatabase>;\n  configure(options: { \n    wasmUrl?: string; \n    debug?: boolean;\n    enablePersistence?: boolean;\n    persistenceKey?: string;\n    cacheSize?: number;\n    enableQueryCache?: boolean;\n    enableBatchOptimization?: boolean;\n    memoryLimit?: number;\n    indexHints?: Record<string, string>;\n  }): void;\n  version: string;\n}\n\nclass JsonicService {\n  private static instance: JsonicService;\n  private db: JsonicDatabase | null = null;\n  private initPromise: Promise<void> | null = null;\n  private jsonicModule: JSONIC | null = null;\n  \n  private constructor() {}\n  \n  static getInstance(): JsonicService {\n    if (!JsonicService.instance) {\n      JsonicService.instance = new JsonicService();\n    }\n    return JsonicService.instance;\n  }\n  \n  async initialize(): Promise<void> {\n    if (this.db) return;\n    \n    if (!this.initPromise) {\n      this.initPromise = this.performInitialization();\n    }\n    \n    return this.initPromise;\n  }\n  \n  private async performInitialization(): Promise<void> {\n    const initStartTime = performance.now();\n    console.log('[JSONIC] Starting initialization...');\n    \n    try {\n      // Build the correct URL for the ES module wrapper\n      const baseUrl = import.meta.env.BASE_URL || '/';\n      \n      // Check if we're in a Web Worker (no window object)\n      const isWorker = typeof window === 'undefined' && typeof self !== 'undefined';\n      \n      // Check for wrapper mode via URL param or env var\n      const urlParams = new URLSearchParams(window.location.search);\n      const wrapperMode = urlParams.get('wrapper') || \n                         import.meta.env.VITE_JSONIC_WRAPPER || \n                         'hybrid'; // Default to hybrid\n      \n      // Select wrapper based on mode\n      let jsonicUrl: string;\n      if (isWorker) {\n        // In worker, use worker-safe wrapper\n        jsonicUrl = `${baseUrl}jsonic-worker-wrapper.js`;\n      } else if (wrapperMode === 'lightweight' || wrapperMode === 'v1') {\n        // Use original lightweight wrapper for comparison\n        console.log('[JSONIC] Using LIGHTWEIGHT v1 wrapper for faster init');\n        jsonicUrl = import.meta.env.DEV \n          ? `${window.location.origin}/jsonic-wrapper.esm.js`\n          : `${baseUrl}jsonic-wrapper.esm.js`;\n      } else if (wrapperMode === 'v3') {\n        // Use full v3.1 wrapper with all features loaded\n        console.log('[JSONIC] Using FULL v3.1 wrapper with all features');\n        jsonicUrl = import.meta.env.DEV \n          ? `${window.location.origin}/jsonic-wrapper-v3.esm.js`\n          : `${baseUrl}jsonic-wrapper-v3.esm.js`;\n      } else {\n        // Use new HYBRID wrapper - fast init with progressive loading\n        console.log('[JSONIC] Using HYBRID wrapper (v4) - fast init + progressive features');\n        jsonicUrl = import.meta.env.DEV \n          ? `${window.location.origin}/jsonic-hybrid/index.js`\n          : `${baseUrl}jsonic-hybrid/index.js`;\n      }\n      \n      console.log('[JSONIC] Loading wrapper from:', jsonicUrl);\n      \n      // Dynamically import the ES module\n      const moduleStartTime = performance.now();\n      const module = await import(/* @vite-ignore */ jsonicUrl) as { default: JSONIC };\n      this.jsonicModule = module.default;\n      console.log(`[JSONIC] Module loaded in ${(performance.now() - moduleStartTime).toFixed(2)}ms`);\n      \n      if (!this.jsonicModule) {\n        throw new Error('JSONIC module not found');\n      }\n      \n      // Configure JSONIC with correct paths for both dev and production (GitHub Pages)\n      let wasmUrl: string;\n      if (isWorker) {\n        // In worker, always use the GitHub Pages path\n        wasmUrl = '/agentx-benchmark-ui/jsonic_wasm_bg.wasm';\n      } else {\n        // In main thread, check the current path\n        wasmUrl = window.location.pathname.startsWith('/agentx-benchmark-ui/') \n          ? '/agentx-benchmark-ui/jsonic_wasm_bg.wasm'\n          : `${baseUrl}jsonic_wasm_bg.wasm`;\n      }\n        \n      // Configure based on wrapper mode\n      const configStartTime = performance.now();\n      const config: any = {\n        wasmUrl,\n        debug: true, // Enable debug mode to see what's happening\n        enablePersistence: false, // Disabled to avoid reloading on every refresh\n        persistenceKey: 'agentx_benchmark_db'\n      };\n      \n      // Add v3/hybrid specific configs\n      if (wrapperMode === 'v3' || wrapperMode === 'hybrid') {\n        config.cacheSize = 100; // LRU cache for query results\n        config.enableQueryCache = true;\n        config.enableBatchOptimization = true;\n        config.memoryLimit = 100 * 1024 * 1024; // 100MB limit\n        config.indexHints = {\n          // Add index hints for frequently queried fields\n          'testId': 'hash',\n          'timestamp': 'btree',\n          'status': 'hash',\n          'agentId': 'hash',\n          'type': 'hash'\n        };\n        \n        // Hybrid-specific: preload commonly used features\n        if (wrapperMode === 'hybrid') {\n          config.preloadFeatures = ['cache', 'batch']; // Preload in background after init\n        }\n      }\n      \n      this.jsonicModule.configure(config);\n      console.log(`[JSONIC] Configuration completed in ${(performance.now() - configStartTime).toFixed(2)}ms`);\n      \n      console.log('JSONIC version:', this.jsonicModule.version);\n      console.log('WASM URL:', wasmUrl);\n      console.log('Features: Query caching, Batch operations, Index optimization, OPFS persistence');\n      \n      const dbCreateStartTime = performance.now();\n      this.db = await this.jsonicModule.createDatabase({\n        enablePersistence: false, // Disabled to avoid reloading on every refresh\n        persistenceKey: 'agentx_benchmark_db',\n        cacheSize: 100,\n        enableQueryCache: true,\n        enableBatchOptimization: true,\n        memoryLimit: 100 * 1024 * 1024,\n        indexHints: {\n          'testId': 'hash',\n          'timestamp': 'btree',\n          'status': 'hash',\n          'agentId': 'hash',\n          'type': 'hash'\n        },\n        debug: true // Enable debug mode\n      });\n      console.log(`[JSONIC] Database created in ${(performance.now() - dbCreateStartTime).toFixed(2)}ms`);\n      console.log('JSONIC v3.1 database initialized with performance optimizations');\n      \n      const statsStartTime = performance.now();\n      const stats = await this.db.stats();\n      console.log(`[JSONIC] Stats retrieved in ${(performance.now() - statsStartTime).toFixed(2)}ms`);\n      console.log('JSONIC stats:', stats);\n      \n      const totalInitTime = performance.now() - initStartTime;\n      console.log(`[JSONIC] Total initialization time: ${totalInitTime.toFixed(2)}ms`);\n      \n      // Log warning if initialization is slow\n      if (totalInitTime > 1000) {\n        console.warn(`[JSONIC] ‚ö†Ô∏è Slow initialization detected: ${totalInitTime.toFixed(2)}ms`);\n      }\n    } catch (error) {\n      console.error('Failed to initialize JSONIC:', error);\n      console.error(`[JSONIC] Failed after ${(performance.now() - initStartTime).toFixed(2)}ms`);\n      throw error;\n    }\n  }\n  \n  async getDatabase(): Promise<JsonicDatabase> {\n    if (!this.db) {\n      await this.initialize();\n    }\n    \n    if (!this.db) {\n      throw new Error('JSONIC database not initialized');\n    }\n    \n    return this.db;\n  }\n  \n  async insert(data: any): Promise<string> {\n    const db = await this.getDatabase();\n    return db.insert(data);\n  }\n  \n  async get(id: string): Promise<any> {\n    const db = await this.getDatabase();\n    return db.get(id);\n  }\n  \n  async update(id: string, data: any): Promise<void> {\n    const db = await this.getDatabase();\n    const result = await db.update(id, data);\n    if (!result) {\n      throw new Error('Failed to update document');\n    }\n  }\n  \n  async delete(id: string): Promise<void> {\n    const db = await this.getDatabase();\n    const result = await db.delete(id);\n    if (!result) {\n      throw new Error('Failed to delete document');\n    }\n  }\n  \n  async listIds(): Promise<string[]> {\n    const db = await this.getDatabase();\n    return db.list();\n  }\n  \n  async getStats(): Promise<any> {\n    const db = await this.getDatabase();\n    return db.stats();\n  }\n  \n  async query(filter: (item: any) => boolean): Promise<any[]> {\n    const db = await this.getDatabase();\n    const ids = await db.list();\n    const results: any[] = [];\n    \n    for (const id of ids) {\n      const doc = await db.get(id);\n      if (doc && doc.content) {\n        // The actual data is in doc.content\n        if (filter(doc.content)) {\n          results.push({ id, ...doc.content });\n        }\n      }\n    }\n    \n    return results;\n  }\n\n  // New MongoDB-like query methods\n  async findDocuments(filter: any, options?: QueryOptions): Promise<any[]> {\n    const db = await this.getDatabase();\n    return db.query(filter, options);\n  }\n\n  async findOne(filter: any): Promise<any> {\n    const db = await this.getDatabase();\n    return db.findOne(filter);\n  }\n\n  find(filter: any = {}): QueryChainable {\n    // Return a promise that resolves to a chainable query\n    const dbPromise = this.getDatabase();\n    \n    const chainable = {\n      sort: function(_sortSpec: Record<string, number>) {\n        return this;\n      },\n      limit: function(_n: number) {\n        return this;\n      },\n      skip: function(_n: number) {\n        return this;\n      },\n      project: function(_projection: Record<string, boolean>) {\n        return this;\n      },\n      exec: async function() {\n        const db = await dbPromise;\n        return db.find(filter).exec();\n      },\n      toArray: async function() {\n        const db = await dbPromise;\n        return db.find(filter).toArray();\n      },\n      count: async function() {\n        const db = await dbPromise;\n        return db.find(filter).count();\n      }\n    } as QueryChainable;\n\n    // Make chainable methods actually chain properly\n    let queryOptions: QueryOptions = {};\n    \n    chainable.sort = (sortSpec: Record<string, number>) => {\n      queryOptions.sort = Object.entries(sortSpec).map(([k, v]) => [k, v]);\n      return chainable;\n    };\n    \n    chainable.limit = (n: number) => {\n      queryOptions.limit = n;\n      return chainable;\n    };\n    \n    chainable.skip = (n: number) => {\n      queryOptions.skip = n;\n      return chainable;\n    };\n    \n    chainable.project = (projection: Record<string, boolean>) => {\n      queryOptions.projection = projection;\n      return chainable;\n    };\n    \n    chainable.exec = async () => {\n      const db = await dbPromise;\n      return db.query(filter, queryOptions);\n    };\n    \n    chainable.toArray = async () => {\n      const db = await dbPromise;\n      return db.query(filter, queryOptions);\n    };\n    \n    chainable.count = async () => {\n      const db = await dbPromise;\n      return db.find(filter).count();\n    };\n    \n    return chainable;\n  }\n\n  // Batch operations for v3.1 performance\n  async insertMany(documents: any[]): Promise<string[]> {\n    const db = await this.getDatabase();\n    return db.insertMany(documents);\n  }\n\n  async updateMany(filter: any, update: any): Promise<UpdateResult> {\n    const db = await this.getDatabase();\n    return db.updateMany(filter, update);\n  }\n\n  async deleteMany(filter: any): Promise<DeleteResult> {\n    const db = await this.getDatabase();\n    return db.deleteMany(filter);\n  }\n\n  // Aggregation pipeline for analytics\n  async aggregate(pipeline: any[]): Promise<any[]> {\n    const db = await this.getDatabase();\n    return db.aggregate(pipeline);\n  }\n\n  // Debug and performance monitoring\n  async getDebugInfo(): Promise<DebugInfo> {\n    const db = await this.getDatabase();\n    return db.getDebugInfo();\n  }\n\n  async clearCache(): Promise<void> {\n    const db = await this.getDatabase();\n    db.clearCache();\n  }\n\n  async clearProfiler(): Promise<void> {\n    const db = await this.getDatabase();\n    db.clearProfiler();\n  }\n\n  // Helper method for benchmark statistics using aggregation\n  async getBenchmarkStats(testId?: string): Promise<any> {\n    const pipeline: any[] = [];\n    \n    if (testId) {\n      pipeline.push({ $match: { testId } });\n    }\n    \n    pipeline.push(\n      {\n        $group: {\n          _id: '$testId',\n          avgDuration: { $avg: '$duration' },\n          minDuration: { $min: '$duration' },\n          maxDuration: { $max: '$duration' },\n          totalRuns: { $sum: 1 },\n          successCount: { $sum: { $cond: [{ $eq: ['$status', 'success'] }, 1, 0] } },\n          failureCount: { $sum: { $cond: [{ $eq: ['$status', 'failure'] }, 1, 0] } }\n        }\n      },\n      {\n        $sort: { totalRuns: -1 }\n      }\n    );\n    \n    return this.aggregate(pipeline);\n  }\n}\n\nexport const jsonicService = JsonicService.getInstance();","// Web Worker for JSONIC database operations\n// This runs in a separate thread to avoid blocking the main UI thread\n\nimport { jsonicService } from './jsonicService';\n\n// Post messages back to the main thread\nconst postProgress = (progress: any) => {\n  self.postMessage({ type: 'progress', payload: progress });\n};\n\nconst performMigration = async () => {\n  try {\n    console.log('üîß WORKER: Starting JSONIC migration...');\n    postProgress({\n      phase: 'loading',\n      current: 0,\n      total: 100,\n      message: 'Loading data in background...',\n      percentage: 10,\n    });\n\n    // In a worker, we need to construct the full URL to the data file\n    const basePath = '/agentx-benchmark-ui/'; // GitHub Pages base path\n    const dataUrl = new URL(`${basePath}data/database.json`, self.location.origin).href;\n\n    const response = await fetch(dataUrl);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch database.json: ${response.status}`);\n    }\n    const jsonData = await response.json();\n\n    const totalDocs =\n      (jsonData.benchmark_runs?.length || 0) +\n      (jsonData.model_performance?.length || 0) +\n      (jsonData.test_results?.length || 0) +\n      (jsonData.performance_trends?.length || 0);\n\n    console.log(`üîß WORKER: Processing ${totalDocs} documents`);\n\n    postProgress({\n      phase: 'migrating',\n      current: 0,\n      total: totalDocs,\n      message: 'Initializing JSONIC in worker...',\n      percentage: 15,\n    });\n\n    // Initialize JSONIC in the worker thread\n    await jsonicService.initialize();\n\n    let migratedCount = 0;\n    const BATCH_SIZE = 50; // Larger batches are fine in a worker\n\n    const insertBatch = async (documents: any[]) => {\n      for (let i = 0; i < documents.length; i += BATCH_SIZE) {\n        const batch = documents.slice(i, Math.min(i + BATCH_SIZE, documents.length));\n\n        // Insert batch in parallel within worker\n        await Promise.all(\n          batch.map(doc => jsonicService.insert(doc))\n        );\n\n        migratedCount += batch.length;\n        const percentage = 20 + (migratedCount / totalDocs) * 70;\n        \n        postProgress({\n          phase: 'migrating',\n          current: migratedCount,\n          total: totalDocs,\n          message: `Processing documents... (${migratedCount}/${totalDocs})`,\n          percentage,\n        });\n      }\n    };\n\n    // Helper to create document with type tagging\n    const createDocument = (type: string, data: any, runId?: string) => ({\n      _type: type,\n      _runId: runId,\n      _timestamp: new Date().toISOString(),\n      ...data\n    });\n\n    // Process data in order of importance\n    if (jsonData.benchmark_runs) {\n      const docs = jsonData.benchmark_runs.map((run: any) => \n        createDocument('benchmark_run', run)\n      );\n      await insertBatch(docs);\n      console.log(`üîß WORKER: Migrated ${docs.length} benchmark runs`);\n    }\n\n    if (jsonData.model_performance) {\n      const docs = jsonData.model_performance.map((perf: any) => \n        createDocument('model_performance', perf, perf.run_id)\n      );\n      await insertBatch(docs);\n      console.log(`üîß WORKER: Migrated ${docs.length} model performance records`);\n    }\n\n    if (jsonData.test_results) {\n      const docs = jsonData.test_results.map((test: any) => \n        createDocument('test_result', test, test.run_id)\n      );\n      await insertBatch(docs);\n      console.log(`üîß WORKER: Migrated ${docs.length} test results`);\n    }\n\n    if (jsonData.performance_trends) {\n      const docs = jsonData.performance_trends.map((trend: any) => \n        createDocument('performance_trend', trend)\n      );\n      await insertBatch(docs);\n      console.log(`üîß WORKER: Migrated ${docs.length} performance trends`);\n    }\n\n    postProgress({\n      phase: 'complete',\n      current: totalDocs,\n      total: totalDocs,\n      message: `‚úÖ Migration complete! ${totalDocs} documents processed.`,\n      percentage: 100,\n    });\n\n    console.log(`üéâ WORKER: Migration successful - ${totalDocs} documents`);\n    self.postMessage({ type: 'migrationComplete', payload: true });\n\n  } catch (error) {\n    console.error('‚ùå WORKER: Migration failed:', error);\n    postProgress({\n      phase: 'error',\n      current: 0,\n      total: 100,\n      message: error instanceof Error ? error.message : 'Unknown worker error',\n      percentage: 0,\n    });\n    self.postMessage({ type: 'migrationComplete', payload: false });\n  }\n};\n\n// Listen for messages from the main thread\nself.onmessage = (event) => {\n  if (event.data.type === 'startMigration') {\n    performMigration();\n  }\n};\n\nexport {};"],"names":["JsonicService","initStartTime","baseUrl","isWorker","wrapperMode","jsonicUrl","moduleStartTime","module","wasmUrl","configStartTime","config","dbCreateStartTime","statsStartTime","stats","totalInitTime","error","data","id","filter","db","ids","results","doc","options","dbPromise","chainable","_sortSpec","_n","_projection","queryOptions","sortSpec","k","v","projection","documents","update","pipeline","testId","jsonicService","postProgress","progress","performMigration","basePath","dataUrl","response","jsonData","totalDocs","migratedCount","BATCH_SIZE","insertBatch","batch","percentage","createDocument","type","runId","docs","run","perf","test","trend","event"],"mappings":"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"}
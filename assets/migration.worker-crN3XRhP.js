class d{static instance;db=null;initPromise=null;jsonicModule=null;constructor(){}static getInstance(){return d.instance||(d.instance=new d),d.instance}async initialize(){if(!this.db)return this.initPromise||(this.initPromise=this.performInitialization()),this.initPromise}async performInitialization(){try{const e="/agentx-benchmark-ui/",s=typeof window>"u"&&typeof self<"u";let t;s?t=`${e}jsonic-worker-wrapper.js`:t=`${e}jsonic-wrapper.esm.js`;const a=await import(t);if(this.jsonicModule=a.default,!this.jsonicModule)throw new Error("JSONIC module not found");let n;s?n="/agentx-benchmark-ui/jsonic_wasm_bg.wasm":n=window.location.pathname.startsWith("/agentx-benchmark-ui/")?"/agentx-benchmark-ui/jsonic_wasm_bg.wasm":`${e}jsonic_wasm_bg.wasm`,this.jsonicModule.configure({wasmUrl:n,debug:!1,enablePersistence:!0,persistenceKey:"agentx_benchmark_db"}),console.log("JSONIC version:",this.jsonicModule.version),console.log("WASM URL:",n),this.db=await this.jsonicModule.createDatabase({enablePersistence:!0,persistenceKey:"agentx_benchmark_db"}),console.log("JSONIC database initialized with MongoDB-like queries and OPFS persistence");const i=await this.db.stats();console.log("JSONIC stats:",i)}catch(e){throw console.error("Failed to initialize JSONIC:",e),e}}async getDatabase(){if(this.db||await this.initialize(),!this.db)throw new Error("JSONIC database not initialized");return this.db}async insert(e){return(await this.getDatabase()).insert(e)}async get(e){return(await this.getDatabase()).get(e)}async update(e,s){if(!await(await this.getDatabase()).update(e,s))throw new Error("Failed to update document")}async delete(e){if(!await(await this.getDatabase()).delete(e))throw new Error("Failed to delete document")}async listIds(){return(await this.getDatabase()).list()}async getStats(){return(await this.getDatabase()).stats()}async query(e){const s=await this.getDatabase(),t=await s.list(),a=[];for(const n of t){const i=await s.get(n);i&&i.content&&e(i.content)&&a.push({id:n,...i.content})}return a}async findDocuments(e,s){return(await this.getDatabase()).query(e,s)}async findOne(e){return(await this.getDatabase()).findOne(e)}find(e={}){const s=this.getDatabase(),t={sort:function(n){return this},limit:function(n){return this},skip:function(n){return this},project:function(n){return this},exec:async function(){return(await s).find(e).exec()},toArray:async function(){return(await s).find(e).toArray()}};let a={};return t.sort=n=>(a.sort=Object.entries(n).map(([i,l])=>[i,l]),t),t.limit=n=>(a.limit=n,t),t.skip=n=>(a.skip=n,t),t.project=n=>(a.projection=n,t),t.exec=async()=>(await s).query(e,a),t.toArray=async()=>(await s).query(e,a),t}}const h=d.getInstance(),u=c=>{self.postMessage({type:"progress",payload:c})},f=async()=>{try{console.log("🔧 WORKER: Starting JSONIC migration..."),u({phase:"loading",current:0,total:100,message:"Loading data in background...",percentage:10});const c="/agentx-benchmark-ui/",e=new URL(`${c}data/database.json`,self.location.origin).href,s=await fetch(e);if(!s.ok)throw new Error(`Failed to fetch database.json: ${s.status}`);const t=await s.json(),a=(t.benchmark_runs?.length||0)+(t.model_performance?.length||0)+(t.test_results?.length||0)+(t.performance_trends?.length||0);console.log(`🔧 WORKER: Processing ${a} documents`),u({phase:"migrating",current:0,total:a,message:"Initializing JSONIC in worker...",percentage:15}),await h.initialize();let n=0;const i=50,l=async r=>{for(let o=0;o<r.length;o+=i){const m=r.slice(o,Math.min(o+i,r.length));await Promise.all(m.map(p=>h.insert(p))),n+=m.length;const b=20+n/a*70;u({phase:"migrating",current:n,total:a,message:`Processing documents... (${n}/${a})`,percentage:b})}},g=(r,o,m)=>({_type:r,_runId:m,_timestamp:new Date().toISOString(),...o});if(t.benchmark_runs){const r=t.benchmark_runs.map(o=>g("benchmark_run",o));await l(r),console.log(`🔧 WORKER: Migrated ${r.length} benchmark runs`)}if(t.model_performance){const r=t.model_performance.map(o=>g("model_performance",o,o.run_id));await l(r),console.log(`🔧 WORKER: Migrated ${r.length} model performance records`)}if(t.test_results){const r=t.test_results.map(o=>g("test_result",o,o.run_id));await l(r),console.log(`🔧 WORKER: Migrated ${r.length} test results`)}if(t.performance_trends){const r=t.performance_trends.map(o=>g("performance_trend",o));await l(r),console.log(`🔧 WORKER: Migrated ${r.length} performance trends`)}u({phase:"complete",current:a,total:a,message:`✅ Migration complete! ${a} documents processed.`,percentage:100}),console.log(`🎉 WORKER: Migration successful - ${a} documents`),self.postMessage({type:"migrationComplete",payload:!0})}catch(c){console.error("❌ WORKER: Migration failed:",c),u({phase:"error",current:0,total:100,message:c instanceof Error?c.message:"Unknown worker error",percentage:0}),self.postMessage({type:"migrationComplete",payload:!1})}};self.onmessage=c=>{c.data.type==="startMigration"&&f()};
//# sourceMappingURL=migration.worker-crN3XRhP.js.map
